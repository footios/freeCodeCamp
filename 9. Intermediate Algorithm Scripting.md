# freeCodeCamp  
# Intermediate Algorithm Scripting Challenges <a name="goUp"/>
> (2018 / September - October)
>
> Here are my solutions to the challenges. 
> 
> They are not the best solutions, but they show my progress.
> 
> Note. Here come only the challenges I've found hard to pass. 
> 
> Spool up the FTL drive!

* [9. Intermediate Algorithm Scripting](#InterAlgo)
    * [Sum All Numbers in a Range](#sumNum)
    * [Diff Two Arrays](#difArr)
    * [Seek and Destroy](#seekD)
    * [Wherefore art thou](#art)
    * [Spinal Tap Case](#spinal)
    * [Pig Latin](#pig)
    * [Search and Replace](#search) 
    * [DNA Pairing](#dna)
    * [Missing letters](#missing)
    * [Sorted Union](#sunion)
    * [Convert HTML Entities](#convert)
    * [Sum All Primes](#sumPrimes)
    * [](#whereBelong)
    * [Mutations](#mutations)
    * [Chunky Monkey](#chunkyMonkey)
       
     
    
# <a name="InterAlgo"/> Intermediate Algorithm Scripting

## <a name="sumNum"/> Sum All Numbers in a Range]

```
   // Sum All Numbers in a Range
   // We'll pass you an array of two numbers. 
   // Return the sum of those two numbers 
   // plus the sum of all the numbers between them.
   
   // It took me 17'
   
    function sumAll(arr) {
    
      // First we sort the array. 
      // This will allow us to get the highest number in the reduce method, as second in the array. 
      let temp = [];
      temp = arr.sort((a, b) => a - b);

      let total = 0;
      total = temp.reduce((a, b) => {
         
        // Get all the numbers between a and b.
        let numbers = [];
        do {
          numbers.push(b--);
        } while (a <= b);

        // Calculate the sum.
        let sum = 0;
        sum = numbers.reduce((a, b) => a + b);
        return sum;
      })
      return total;
    }

    console.log(sumAll([10, 5]));
    
```
[Go up](#goUp)

## <a name="difArr"/> Diff Two Arrays
```
    // Compare two arrays and return a new array with
    // any items only found in one of the two given arrays,
    // but not both. In other words, return the symmetric
    // difference of the two arrays.

    // It took me 8 hours. I was trying too hard to be smart again.
    // I tried for loop, reduce, forEach and filter
    // Then I looked at the hints and tried filter again
    
  function diffArray(arr1, arr2) {
      let newArr = []
      let temp = arr1.concat(arr2);

      arr1.filter(item => {
        if (!arr2.includes(item)) {
          newArr.push(item);
        }
      })

      arr2.filter(item => {
        if (!arr1.includes(item)) {
          newArr.push(item);
        }
      })

      return newArr;
    }

    console.log('result ',
      diffArray(["diorite", "andesite", "grass", "dirt", "pink wool", "dead shrub"],
        ["diorite", "andesite", "grass", "dirt", "dead shrub"]));
```
[Go up](#goUp)
 ## <a name="seekD"/> Seek and Destroy
```
// You will be provided with an initial array 
// (the first argument in the destroyer function), 
// followed by one or more arguments. Remove all elements 
// from the initial array that are of the same value as these arguments.
// Note
// You have to use the arguments object.

// In 1 hour.
//I have to think very well fist.
    function destroyer(arr) {
    
      // Remove all the values
      
      let items = []
      let newArr = []
      
      // we start iterating from 1, so we skip the array.
      for (var i = 1; i < arguments.length; i++) {
        items.push(arguments[i]);
      }

      arr.filter(j => {
        if (!items.includes(j)) {
          newArr.push(j);
        }
      })

      return newArr;
    }
    console.log('result ', destroyer([3, 5, 1, 2, 2], 2, 3, 5));
```
[Go up](#goUp)

## <a name="art"/> Wherefore art thou
> We got a hint from [the forum](https://www.freecodecamp.org/forum/t/wherefore-art-thou-problem/187652/4)
> But it didn't pass all the tests, at first. Then we saw another solution from the forum, which we have down below,
> and we fixed this one too. As well as the next one. 
```
// Make a function that looks through an array of objects 
// (first argument) and returns an array of all objects 
// that have matching name and value pairs (second argument). 
// Each name and value pair of the source object has to be 
// present in the object from the collection if it is to be 
// included in the returned array.

// In 2:30'
// I tried different ways of iterating through the objects.
// But I was not able to acces their values.
// I got a hint from a post in the forum.

    function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];
      let temp = Object.keys(source)
     
      arr = collection.filter(x => {
      
        for (var i = 0; i < temp.length; i++) {
        
           // Here (x[temp[i]]) we calculate 
          // the property of collection
          // with the help of temp,
          // wich is the prop of source.
          // x is every object in the collection array.
          // temp is every property
          // i is the value of the property.
          // So it's like doing obj[prop[value]]

          // So we check the values of the source.
          // If there is a value
          // that doesn't match a value of the i...
          // give filter a false
          // else give it true
          // So in case of {bat: 2}
          // There is no apple so it gives false.
          // If you reverse the if to === and true
          // it gives all properties of i that
          // have at least one matching pair.
         
         
           if (x[temp[i]] !== source[temp[i]]) {
            return false
          }
        }
        return true

                // Code that didn't pass all tests
                //   if (x[temp[i]] === source[temp[i]]) {
                //     return x
                //   }
                // }
      })
      return arr;
    }
    console.log(
      whatIsInAName([{
        first: "Romeo",
        last: "Montague"
      }, {
        first: "Mercutio",
        last: null
      }, {
        first: "Tybalt",
        last: "Capulet"
      }], {
        last: "Capulet"
      }));
```
> Here we use the for-in loop to access the obj's keys and values
```
    function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];
      arr = collection.filter(x => {
    
       for (let prop in source) {
         if (x[prop] !== source[prop]) {
           return false
         }
       }
       return true;
      })
      return arr;
    }
```
[Go up](#goUp)

> This one passes all the tests
> We got it from the [forum](https://www.freecodecamp.org/forum/t/wherefore-art-thou-solution-returning/180997)
```
function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];

      arr = collection.filter(item => {

        // Check the values of source.
        // If there is a value
        // that doesn't match a value of the item...
        // give filter a false
        // else give it true
        // So in case of {bat: 2}
        // There is no apple so it gives false.
        // If you reverse the if to === and true
        // it gives all properties of item that
        // have at least one matching pair.
        // So we get results as our previus code
        
        for (var i in source) {
          if (source[i] != item[i]) {
            return false;
          }
        }
        return true
      })
      return arr;
    }

    console.log(whatIsInAName([{
      "apple": 1,
      "bat": 2
    }, {
      "bat": 2
    }, {
      "apple": 1,
      "bat": 2,
      "cookie": 2
    }], {
      "apple": 1,
      "bat": 2
    }));

```
[Go up](#goUp)
> In this one we created a pure function, to make the code less convoluted.
```
  function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];
      
      // a pure function
      let getProperties = (x) => {
        for (let prop in source) {
          if (x[prop] !== source[prop]) {
            return false
          }
        }
        return true
      }
      arr = collection.filter(getProperties)
      return arr;
    }

```
[Go up](#goUp)

## <a name="spinal"/> Spinal Tap Case
> Convert a string to spinal case. 
> Spinal case is all-lowercase-words-joined-by-dashes.
>
> Solved in 1:30
> I saw the way of seperating the AllThe in the [forum.](https://www.freecodecamp.org/forum/t/spinal-tap-case-regexp/209981/2)
>
> Another link about replacing [capturing groups](https://stackoverflow.com/questions/3954927/js-regex-how-to-replace-the-captured-groups-only)
```
    function spinalCase(str) {

      let regex = /([a-z])([A-Z])/g;
      let regex2 = /\s|_|-/g;
      let newStr = str.replace(regex, '$1 $2').replace(regex2, '-');
      return newStr.toLowerCase();
    }
    console.log(spinalCase("AllThe-small Things"));

```
> Solution with lookahead
```
    function spinalCase(str) {

      let regex = /([a-z](?=[A-Z]))/g;
      let regex2 = /\s|_|-/g;
      let newStr = str.replace(regex, '$1 ').replace(regex2, '-');
      return newStr.toLowerCase();
    }
    console.log(spinalCase("thisIsSpinalTap"));
```
[Go up](#goUp)

> Solution from the forum, with lookahead and split.

```
// I got this part from the forum: [\W^_]+|
    function spinalCase(str) {

      let regex = /[\W^_]+|(?=[A-Z])/g;
      let regex2 = /\s|_|-/g;
      let newStr = str.split(regex).join(' ').replace(regex2, '-')
      return newStr //.toLowerCase();
```
[Go up](#goUp)

## <a name="pig"/> Pig Latin
> Translate the provided string to pig latin.
>
> Pig Latin takes the first consonant (or consonant cluster) of an English word, moves it to the end of the word and suffixes an "ay".
>
> If a word begins with a vowel you just add "way" to the end.
>
> Input strings are guaranteed to be English words in all lowercase.
>
> [FFC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/pig-latin/)
>
>[Better solution in the forum](https://www.freecodecamp.org/forum/t/pig-latin-solved-no-help-needed/219911)
```
    function translatePigLatin(str) {
      // This is not how one should solve this,
      // but it works

      let newStr = '';
      let regex = /^[a|e|i|o|u]/; // firstLetter a vowel
      let regex2 = /.(?=a|e|i|o|u)/; // firstLetters not vowels
      let regex3 = /a|e|i|o|u/g; // words with vowels
      let regex4 = /[a|e|i|o|u]$/; // only last letter a vowel
      let replaceRegex = /,/g;


      // By this, we can check if the word has only one vowel and that's at the end.
      // Split the word in two.
      // One piece till one by the last letter.
      // Second piece the last letter.
      
      let butTheLast = str.split('').splice(0, str.length - 1);
      let last = str.split('').splice(str.length - 1);
      if (!butTheLast.join('').match(regex3) && last.join('').match(regex3)) {
        newStr = str.concat('ay')
      }
      
      // if it starts with a vowel
      if (str.match(regex)) {
        newStr = str.concat('way');
        
      // If it starts with a consonant and the last is not a vowel
      } else if (str.match(regex2) && butTheLast.join('').match(regex3)) {
        let arr = str.split('')
        let consonants = str.match(regex2);
        
        // Here if we console.log(consonants);
        // We get: ["f", index: 0, input: "consonants", groups: undefined]
        // So if we log consonants.index is 0, and .input is consonants.
        // We use the index to splice the consonants.
        // The replace method is to get rid of the comas.
        
        let firstLetters = arr.splice(0, consonants.index + 1);
        newStr = arr.join('').concat(firstLetters + 'ay').replace(replaceRegex, '');
        
        // if the word doesn't have a vowel
      } else if (!str.match(regex3)) {
        newStr = str.concat('ay')
       } 
      return newStr;
    }

    console.log(translatePigLatin('consonants'));
```
[Go up](#goUp)

> The FCC basic solution has a very interesting line of code.
>
> First of all it's very consice. It uses only one regex. Then it orders the if statements in a very accurate way.
```
    function translatePigLatin(str) {
      // Create variables to be used
      var pigLatin = '';
      var regex = /[aeiou]/gi;

      // Check if the first character is a vowel
      if (str[0].match(regex)) {
        pigLatin = str + 'way';

      } else if (str.match(regex) === null) {
        // Check if the string contains only consonants
        pigLatin = str + 'ay';
      } else {

        // Find how many consonants before the first vowel.
        var vowelIndice = str.indexOf(str.match(regex)[0]);
        
        //Above is the code I find interesting. It's str.match(regex)[0]
        // If we log console.log(str.match(regex));
        // We get ["o", "o", "a"]
        // So str.match(regex)[0] is the first "o". 

      
        // Take the string from the first vowel to the last char
        // then add the consonants that were previously omitted and add the ending.
        pigLatin = str.substr(vowelIndice) + str.substr(0, vowelIndice) + 'ay';
      }

      return pigLatin;
    }

    // test here
    translatePigLatin("consonant");
```
[Go up](#goUp)
> 
> Check here the intermadiate solution... => wow am I ever going to write code like this!
```
    function translatePigLatin(str) {
      // Thinking process:
      // I need to know where is the first vowel, starting from the
      // first letter. So str.charAt(0) which gives 'c'
      // so indexOf('c') == -1. If that's true call again check adding
      // 1, and by this checking the next index, until you find the
      // first vowel, then return its index.

      let check = inx => {
        return ['a', 'i', 'o', 'u,', 'e']
          .indexOf(str.charAt(inx)) == -1 ? check(inx + 1) : inx;
      }

      // Take the str from the beginning and
      // if the first letter is a vowel then  concat first a 'w'.
      // If not, then concat the first letters untill the first vowel
      // At the ende add 'ay' to it
      
      return str.substr(check(0))
        .concat((check(0) === 0 ? 'w' : str.substr(0, check(0))) + 'ay')
    }
```
[Go up](#goUp)

## <a name="search"/> Search and Replace
> 
> [FCC challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/search-and-replace/)

```
    function myReplace(str, before, after) {

      let newStr = '';

      let regex = /[A-Z]/;
      let before_0 = before.charAt(0);

        // Check if the word starts with a capital letter.
      if (before_0.match(regex)) {
        let after_0 = after.charAt(0).toUpperCase();
        let after_rest = after.slice(1);
        newStr = str.replace(before, after_0 + after_rest);
      } else {
        newStr = str.replace(before, after);
      }

      return newStr;
    }
    console.log(myReplace("He is sleeping on the couch", "sleeping", "sitting"));
  
```
[Go up](#goUp)

> FCC Basic solution
```
function myReplace(str, before, after) {

  // I don't understand why they use indexOf
  // charAt seems more appropriate
  // Anyway their solution is more consice than mine.
  // let index = str.indexOf(before);
  // cosole.log(index);
  //
  // if (str[index] !== str[index].toUpperCase()) {
  //   console.log('ok');
  // }

  if (before.charAt(0) === before.charAt(0).toUpperCase()) {
    after = after.charAt(0).toUpperCase() + after.slice(1);
  }

  str.replace(before, after)

  return str;
}

console.log(
  myReplace("A quick brown fox Jumped over the lazy dog", "Jumped", "leaped"));

```
[Go up](#goUp)

> FCC intermediate solution
```
    function myReplace(str, before, after) {

      let replc = new RegExp(before, 'gi');

      if (/[A-Z]/.test(before.charAt(0))) {
        after = after.charAt(0).toUpperCase() + after.slice(1);
      }

      str.replace(replc, after)

      return str;
    }

    console.log(
      myReplace("A quick brown fox Jumped over the lazy dog", "Jumped", "leaped"));

```
[Go up](#goUp)

## <a name="dna"/> DNA Pairing
>
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/dna-pairing)
>
> [FCC Solutions](https://guide.freecodecamp.org/certifications/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/dna-pairing/)
> 
```
    function pairElement(str) {
      let arr = str.split("");
      let newArr = [];

      for (var i = 0; i < arr.length; i++) {
        switch (arr[i]) {
          case "A":
            newArr.push(["A", "T"])
            break;
          case "T":
            newArr.push(["T", "A"])
            break;
          case "G":
            newArr.push(["G", "C"])
            break;
          case "C":
            newArr.push(["C", "G"])
            break;
        }
      }
      return newArr;
    }

    console.log(pairElement("ATCGA"));
```
[Go up](#goUp)
> FCC intermediate solution
```
    
    function pairElement(str) {
      //create object for pair lookup
      var pairs = {
        "A": "T",
        "T": "A",
        "C": "G",
        "G": "C"
      }
      let arr = str.split('');

      // the pairs[letter] gives us the value of letter
      
      return arr.map(letter => [letter, pairs[letter]])
    }

    console.log(pairElement("GCG"));
```
[Go up](#goUp)

## <a name="missing"/> Missing letters
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/missing-letters)
>
> Again I did more than it was needed. The solution is more simple.
```
    function fearNotLetter(str) {

      let newStr = '';

      let dif = 0;
      let num = 0;
      let length = str.length;

      // 97 is a in ASCII
      for (var i = 0; i < length; i++) {
        dif = str.charCodeAt(0) - 97
        num = i + 97 + dif;
        if (str.charCodeAt(i) !== num) {
          newStr = String.fromCharCode(num);
          break;
        } else if (length === 26) {
          return undefined;
        }
      }

      return newStr;
    }

    console.log(fearNotLetter("abcdefghijklmnopqrstuvwxyz"));
```
[Go up](#goUp)

## <a name="sunion"/> Sorted Union
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/sorted-union/)
>
> I got the reduce solution from [staovf](https://stackoverflow.com/questions/9229645/remove-duplicate-values-from-js-array)
>
> I just had to figure out how to pass the array so I get the [5] and [4] as they where.
```
  function uniteUnique(arr) {
      let newArr = arr.concat(...arguments)

      let noDub = [];

      noDub = newArr.reduce((acc, num) => {
        if (acc.indexOf(num) < 0) {
          acc.push(num);
        }
        return acc;
      }, []);
      
      return noDub;
    }

    console.log(uniteUnique([1, 3, 2], [1, [5]], [2, [4]]));
```
[Go up](#goUp)

## <a name="convert"/> Convert HTML Entities
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/convert-html-entities/)
>

```
    function convertHTML(str) {
      let newStr = '';
      let regex = /&/g;
      let regex1 = /</g;
      let regex2 = />/g;
      let regex3 = /"/g;
      let regex4 = /'/g;
      let regex5 = /&|<|>|'|"/g;

      // This is strange.
      // It should be if not.
      if (str.search(regex5)) {
        newStr = str;
      }

      let replaceEntities = entitie => {
        if (entitie === '&') {
          newStr = str.replace(regex, '&amp;')
        } else if (entitie === '<') {
          newStr = str.replace(regex1, '&lt;')
        } else if (entitie === '>') {
          newStr = str.replace(regex2, '&gt;')
        } else if (entitie === '"') {
          newStr = str.replace(regex3, '&quot;')
        } else if (entitie === "'") {
          newStr = str.replace(regex4, '&apos;')
        }
      }

      for (var i = 0; i < str.length; i++) {
        replaceEntities(str.charAt(i));
      }
      return newStr;
    }

    console.log(convertHTML('Stuff in "quotation marks"'));
```
[Go up](#goUp)
> Another solution
```
    function convertHTML(str) {
      let arr = str.split('');
      
      for (var i = 0; i < arr.length; i++) {
        switch (arr[i]) {
          case '&':
            arr[i] = '&amp;'; 
            break;
          case '<':
            arr[i] = '&lt;';
            break;
          case '>':
            arr[i] = '&gt;';
            break;
          case '"':
            arr[i] = '&quot;';
            break;
          case "'":
            arr[i] = '&apos;';
            break;
        }
      }
      return arr.join('');
    }

    console.log(convertHTML('Stuff in "quotation marks"'));
```

## <a name="missing"/> Sum All Odd Fibonacci Numbers
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/sum-all-odd-fibonacci-numbers/)
>
> I found the way to get the sequence of fibonachi numbers [here](https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053)
```
function sumFibs(num) {
      let sum = 0;
      let arr = [0, 1];
      let arr1 = []

      // Find the sequence of fibonachi numbers
      for (let i = 2; i < num + 1; i++) {
        arr.push(arr[i - 2] + arr[i - 1])
      }
      // get the odd numbers etc until num
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] % 2 !== 0 && arr[i] <= num) {
          sum += arr[i];
          arr1.push(arr[i])
        }
      }
      console.log(arr1);
      return sum;
    }

    console.log(sumFibs(75025));
```
[Go up](#goUp)

## <a name="sumPrimes"/> Sum All Primes
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/sum-all-primes/)
>
> I found the way to get the primes on [Stackoverflow](https://stackoverflow.com/questions/17389350/prime-numbers-javascript)
```
    function sumPrimes(num) {
    
    function nextPrime(value) {
        if (value > 2) {
          let i, q;
          do {
            i = 3;
            value += 2;
            q = Math.floor(Math.sqrt(value));
            while (i <= q && value % i) {
              i += 2;
            }
          } while (i <= q);
          return value;
        }
        return value === 2 ? 3 : 2;
      }

      let value, result = [];
      for (let i = 0; i < num; i++) {
        value = nextPrime(value);
        result.push(value);
      }

      // I did only this part.

      let sum = 0;
      sum = result.filter(x => x <= num).reduce((acc, value) => acc + value)
      
                              // basic way
                              // let sum = 0;
                              // for (let i = 0; i < result.length; i++) {
                              //   if (result[i] <= num) {
                              //     sum += result[i];
                              //   }
                              // }
      return sum
    }
```
[Go up](#goUp)

## <a name="missing"/> Missing letters
> [FCC Challenge]()
>

```

```
[Go up](#goUp)

## <a name="missing"/> Missing letters
> [FCC Challenge]()
>

```

```
[Go up](#goUp)
