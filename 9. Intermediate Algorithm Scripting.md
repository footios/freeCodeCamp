# <a name="goUp"/> freeCodeCamp  
# Intermediate Algorithm Scripting Challenges 

> (11/10/2018 - 24/10/2018, 80 hours)  
>
> Here are my solutions. 
> 
> They are not the best, but they show my progress.
> 
> Note. Here come only the challenges I've found hard to pass. 
> 
> Now, spool up the FTL drive!

* [9. Intermediate Algorithm Scripting](#InterAlgo)
    * [Sum All Numbers in a Range](#sumNum)
    * [Diff Two Arrays](#difArr)
    * [Seek and Destroy](#seekD)
    * [Wherefore art thou](#art)
    * [Spinal Tap Case](#spinal)
    * [Pig Latin](#pig)
    * [Search and Replace](#search) 
    * [DNA Pairing](#dna)
    * [Missing letters](#missing)
    * [Sorted Union](#sunion)
    * [Convert HTML Entities](#convert)
    * [Sum All Primes](#sumPrimes)
    * [Smallest Common Multiple](#smallest)
    * [Smallest Common Multiple - code from Niels Bom](#niels)
    * [Drop it](#drop)
    * [Steamroller](#stream)
    * [Binary Agents](#binary)
    * [Make a Person](#person)  
    * [Map the Debris](#everything)    
    
    
# <a name="InterAlgo"/> Intermediate Algorithm Scripting

## <a name="sumNum"/> Sum All Numbers in a Range

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/sum-all-numbers-in-a-range/)

Sum All Numbers in a Range

We'll pass you an array of two numbers.

Return the sum of those two numbers, plus the sum of all the numbers between them.
```
   // It took me 17'
   
    function sumAll(arr) {
    
      // First we sort the array. 
      // This will allow us to get the highest number in the reduce method, as second in the array. 
      let temp = [];
      temp = arr.sort((a, b) => a - b);

      let total = 0;
      total = temp.reduce((a, b) => {
         
        // Get all the numbers between a and b.
        let numbers = [];
        do {
          numbers.push(b--);
        } while (a <= b);

        // Calculate the sum.
        let sum = 0;
        sum = numbers.reduce((a, b) => a + b);
        return sum;
      })
      return total;
    }

    console.log(sumAll([10, 5]));
    
```
[Go up](#goUp)

From last repetition.
```
    function sumAll(arr) {

      let newArr = [...arr];

      newArr.sort((a, b) => a - b);
      let first = newArr[0];
      let second = newArr[1];

      let allNumbers = [];
      for (let i = first; i <= second; i++) {
        allNumbers.push(i);
      }

      return allNumbers.reduce((acc, value) => acc + value);
    }
    
    console.log(sumAll([12, 4]));
```
[Go up](#goUp)

## <a name="difArr"/> Diff Two Arrays

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/diff-two-arrays)

Compare two arrays and return a new array with any items only found in one of the two given arrays, but not both. In other words, return the symmetric difference of the two arrays.

Must check the FCC solutions!!!
```
  function diffArray(arr1, arr2) {
      let newArr = []
    
      arr1.filter(item => {
        if (!arr2.includes(item)) {
          newArr.push(item);
        }
      })

      arr2.filter(item => {
        if (!arr1.includes(item)) {
          newArr.push(item);
        }
      })

      return newArr;
    }

    console.log('result ',
      diffArray(["diorite", "andesite", "grass", "dirt", "pink wool", "dead shrub"],
        ["diorite", "andesite", "grass", "dirt", "dead shrub"]));
```
[Go up](#goUp)

FCC Advanced solution.
```
  function diffArray(arr1, arr2) {
  
    // Here we return an array,
    // and because functions are objects,
    // we put the elements of the array,
    // to be functions.
    
      return [
        ...diff(arr1, arr2),
        ...diff(arr2, arr1)
      ]

      function diff(a, b) {
        return a.filter(item => b.indexOf(item) === -1);
      }
    }
    console.log(diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]));
```
[Go up](#goUp)

 ## <a name="seekD"/> Seek and Destroy
 
 [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/seek-and-destroy/)
 
You will be provided with an initial array (the first argument in the destroyer function), 
followed by one or more arguments. Remove all elements  from the initial array that are of the same value as these arguments.
Note: You have to use the arguments object.

Must check FCC solutions
```
    function destroyer(arr) {
    
      // Remove all the values
      
      let items = []
      let newArr = []
      
      // we start iterating from 1, so we skip the array.
      for (var i = 1; i < arguments.length; i++) {
        items.push(arguments[i]);
      }

      arr.filter(j => {
        if (!items.includes(j)) {
          newArr.push(j);
        }
      })

      return newArr;
    }
    console.log('result ', destroyer([3, 5, 1, 2, 2], 2, 3, 5));
```
[Go up](#goUp)

FCC Advanced solution.
```
const destroyer = (arr, ...args) => arr.filter(i => !args.includes(i));
```

## <a name="art"/> Wherefore art thou

[FCC Challenge]()

> We got a hint from [the forum](https://www.freecodecamp.org/forum/t/wherefore-art-thou-problem/187652/4)
> But it didn't pass all the tests, at first. Then we saw another solution from the forum, which we have down below,
> and we fixed this one too. As well as the next one. 
```
// Make a function that looks through an array of objects 
// (first argument) and returns an array of all objects 
// that have matching name and value pairs (second argument). 
// Each name and value pair of the source object has to be 
// present in the object from the collection if it is to be 
// included in the returned array.

// In 2:30'
// I tried different ways of iterating through the objects.
// But I was not able to acces their values.
// I got a hint from a post in the forum.

    function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];
      let temp = Object.keys(source)
     
      arr = collection.filter(x => {
      
        for (var i = 0; i < temp.length; i++) {
        
           // Here (x[temp[i]]) we calculate 
          // the property of collection
          // with the help of temp,
          // wich is the prop of source.
          // x is every object in the collection array.
          // temp is every property
          // i is the value of the property.
          // So it's like doing obj[prop[value]]

          // So we check the values of the source.
          // If there is a value
          // that doesn't match a value of the i...
          // give filter a false
          // else give it true
          // So in case of {bat: 2}
          // There is no apple so it gives false.
          // If you reverse the if to === and true
          // it gives all properties of i that
          // have at least one matching pair.
         
         
           if (x[temp[i]] !== source[temp[i]]) {
            return false
          }
        }
        return true

                // Code that didn't pass all tests
                //   if (x[temp[i]] === source[temp[i]]) {
                //     return x
                //   }
                // }
      })
      return arr;
    }
    console.log(
      whatIsInAName([{
        first: "Romeo",
        last: "Montague"
      }, {
        first: "Mercutio",
        last: null
      }, {
        first: "Tybalt",
        last: "Capulet"
      }], {
        last: "Capulet"
      }));
```
> Here we use the for-in loop to access the obj's keys and values
```
    function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];
      arr = collection.filter(x => {
    
       for (let prop in source) {
         if (x[prop] !== source[prop]) {
           return false
         }
       }
       return true;
      })
      return arr;
    }
```
[Go up](#goUp)

> This one passes all the tests
> We got it from the [forum](https://www.freecodecamp.org/forum/t/wherefore-art-thou-solution-returning/180997)
```
function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];

      arr = collection.filter(item => {

        // Check the values of source.
        // If there is a value
        // that doesn't match a value of the item...
        // give filter a false
        // else give it true
        // So in case of {bat: 2}
        // There is no apple so it gives false.
        // If you reverse the if to === and true
        // it gives all properties of item that
        // have at least one matching pair.
        // So we get results as our previus code
        
        for (var i in source) {
          if (source[i] != item[i]) {
            return false;
          }
        }
        return true
      })
      return arr;
    }

    console.log(whatIsInAName([{
      "apple": 1,
      "bat": 2
    }, {
      "bat": 2
    }, {
      "apple": 1,
      "bat": 2,
      "cookie": 2
    }], {
      "apple": 1,
      "bat": 2
    }));

```
[Go up](#goUp)
> In this one we created a pure function, to make the code less convoluted.
```
  function whatIsInAName(collection, source) {
      // What's in a name?
      var arr = [];
      
      // a pure function
      let getProperties = (x) => {
        for (let prop in source) {
          if (x[prop] !== source[prop]) {
            return false
          }
        }
        return true
      }
      arr = collection.filter(getProperties)
      return arr;
    }

```
[Go up](#goUp)

## <a name="spinal"/> Spinal Tap Case

[FCC Challenge]()

> Convert a string to spinal case. 
> Spinal case is all-lowercase-words-joined-by-dashes.
>
> Solved in 1:30
> I saw the way of seperating the AllThe in the [forum.](https://www.freecodecamp.org/forum/t/spinal-tap-case-regexp/209981/2)
>
> Another link about replacing [capturing groups](https://stackoverflow.com/questions/3954927/js-regex-how-to-replace-the-captured-groups-only)
```
    function spinalCase(str) {

      let regex = /([a-z])([A-Z])/g;
      let regex2 = /\s|_|-/g;
      let newStr = str.replace(regex, '$1 $2').replace(regex2, '-');
      return newStr.toLowerCase();
    }
    console.log(spinalCase("AllThe-small Things"));

```
> Solution with lookahead
```
    function spinalCase(str) {

      let regex = /([a-z](?=[A-Z]))/g;
      let regex2 = /\s|_|-/g;
      let newStr = str.replace(regex, '$1 ').replace(regex2, '-');
      return newStr.toLowerCase();
    }
    console.log(spinalCase("thisIsSpinalTap"));
```
[Go up](#goUp)

> Solution from the forum, with lookahead and split.

```
// I got this part from the forum: [\W^_]+|
    function spinalCase(str) {

      let regex = /[\W^_]+|(?=[A-Z])/g;
      let regex2 = /\s|_|-/g;
      let newStr = str.split(regex).join(' ').replace(regex2, '-')
      return newStr //.toLowerCase();
```
[Go up](#goUp)

## <a name="pig"/> Pig Latin

[FCC Challenge]()
> Translate the provided string to pig latin.
>
> Pig Latin takes the first consonant (or consonant cluster) of an English word, moves it to the end of the word and suffixes an "ay".
>
> If a word begins with a vowel you just add "way" to the end.
>
> Input strings are guaranteed to be English words in all lowercase.
>
> [FFC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/pig-latin/)
>
>[Better solution in the forum](https://www.freecodecamp.org/forum/t/pig-latin-solved-no-help-needed/219911)
```
    function translatePigLatin(str) {
      // This is not how one should solve this,
      // but it works 

      let newStr = '';
      let regex = /^[a|e|i|o|u]/; // firstLetter a vowel
      let regex2 = /.(?=a|e|i|o|u)/; // firstLetters not vowels
      let regex3 = /a|e|i|o|u/g; // words with vowels
      let regex4 = /[a|e|i|o|u]$/; // only last letter a vowel
      let replaceRegex = /,/g;


      // By this, we can check if the word has only one vowel and that's at the end.
      // Split the word in two.
      // One piece till one by the last letter.
      // Second piece the last letter.
      
      let butTheLast = str.split('').splice(0, str.length - 1);
      let last = str.split('').splice(str.length - 1);
      if (!butTheLast.join('').match(regex3) && last.join('').match(regex3)) {
        newStr = str.concat('ay')
      }
      
      // if it starts with a vowel
      if (str.match(regex)) {
        newStr = str.concat('way');
        
      // If it starts with a consonant and the last is not a vowel
      } else if (str.match(regex2) && butTheLast.join('').match(regex3)) {
        let arr = str.split('')
        let consonants = str.match(regex2);
        
        // Here if we console.log(consonants);
        // We get: ["f", index: 0, input: "consonants", groups: undefined]
        // So if we log consonants.index is 0, and .input is consonants.
        // We use the index to splice the consonants.
        // The replace method is to get rid of the comas.
        
        let firstLetters = arr.splice(0, consonants.index + 1);
        newStr = arr.join('').concat(firstLetters + 'ay').replace(replaceRegex, '');
        
        // if the word doesn't have a vowel
      } else if (!str.match(regex3)) {
        newStr = str.concat('ay')
       } 
      return newStr;
    }

    console.log(translatePigLatin('consonants'));
```
[Go up](#goUp)

> The FCC basic solution has a very interesting line of code.
>
> First of all it's very consice. It uses only one regex. Then it orders the if statements in a very accurate way.
```
    function translatePigLatin(str) {
      // Create variables to be used
      var pigLatin = '';
      var regex = /[aeiou]/gi;

      // Check if the first character is a vowel
      if (str[0].match(regex)) {
        pigLatin = str + 'way';

      } else if (str.match(regex) === null) {
        // Check if the string contains only consonants
        pigLatin = str + 'ay';
      } else {

        // Find how many consonants before the first vowel.
        var vowelIndice = str.indexOf(str.match(regex)[0]);
        
        //Above is the code I find interesting. It's str.match(regex)[0]
        // If we log console.log(str.match(regex));
        // We get ["o", "o", "a"]
        // So str.match(regex)[0] is the first "o". 

      
        // Take the string from the first vowel to the last char
        // then add the consonants that were previously omitted and add the ending.
        pigLatin = str.substr(vowelIndice) + str.substr(0, vowelIndice) + 'ay';
      }

      return pigLatin;
    }

    // test here
    translatePigLatin("consonant");
```
[Go up](#goUp)
> 
> Check here the intermadiate solution... => wow am I ever going to write code like this!
```
    function translatePigLatin(str) {
      // Thinking process:
      // I need to know where is the first vowel, starting from the
      // first letter. So str.charAt(0) which gives 'c'
      // so indexOf('c') == -1. If that's true call again check adding
      // 1, and by this checking the next index, until you find the
      // first vowel, then return its index.

      let check = inx => {
        return ['a', 'i', 'o', 'u,', 'e']
          .indexOf(str.charAt(inx)) == -1 ? check(inx + 1) : inx;
      }

      // Take the str from the beginning and
      // if the first letter is a vowel then  concat first a 'w'.
      // If not, then concat the first letters untill the first vowel
      // At the ende add 'ay' to it
      
      return str.substr(check(0))
        .concat((check(0) === 0 ? 'w' : str.substr(0, check(0))) + 'ay')
    }
```
[Go up](#goUp)

## <a name="search"/> Search and Replace
> 
> [FCC challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/search-and-replace/)

```
    function myReplace(str, before, after) {

      let newStr = '';

      let regex = /[A-Z]/;
      let before_0 = before.charAt(0);

        // Check if the word starts with a capital letter.
      if (before_0.match(regex)) {
        let after_0 = after.charAt(0).toUpperCase();
        let after_rest = after.slice(1);
        newStr = str.replace(before, after_0 + after_rest);
      } else {
        newStr = str.replace(before, after);
      }

      return newStr;
    }
    console.log(myReplace("He is sleeping on the couch", "sleeping", "sitting"));
  
```
[Go up](#goUp)

> FCC Basic solution
```
function myReplace(str, before, after) {

  // I don't understand why they use indexOf
  // charAt seems more appropriate
  // Anyway their solution is more consice than mine.
  // let index = str.indexOf(before);
  // cosole.log(index);
  //
  // if (str[index] !== str[index].toUpperCase()) {
  //   console.log('ok');
  // }

  if (before.charAt(0) === before.charAt(0).toUpperCase()) {
    after = after.charAt(0).toUpperCase() + after.slice(1);
  }

  str.replace(before, after)

  return str;
}

console.log(
  myReplace("A quick brown fox Jumped over the lazy dog", "Jumped", "leaped"));

```
[Go up](#goUp)

> FCC intermediate solution
```
    function myReplace(str, before, after) {

      let replc = new RegExp(before, 'gi');

      if (/[A-Z]/.test(before.charAt(0))) {
        after = after.charAt(0).toUpperCase() + after.slice(1);
      }

      str.replace(replc, after)

      return str;
    }

    console.log(
      myReplace("A quick brown fox Jumped over the lazy dog", "Jumped", "leaped"));

```
[Go up](#goUp)

## <a name="dna"/> DNA Pairing
>
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/dna-pairing)
>
> [FCC Solutions](https://guide.freecodecamp.org/certifications/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/dna-pairing/)
> 
```
    function pairElement(str) {
      let arr = str.split("");
      let newArr = [];

      for (var i = 0; i < arr.length; i++) {
        switch (arr[i]) {
          case "A":
            newArr.push(["A", "T"])
            break;
          case "T":
            newArr.push(["T", "A"])
            break;
          case "G":
            newArr.push(["G", "C"])
            break;
          case "C":
            newArr.push(["C", "G"])
            break;
        }
      }
      return newArr;
    }

    console.log(pairElement("ATCGA"));
```
[Go up](#goUp)
> FCC intermediate solution
```
    
    function pairElement(str) {
      //create object for pair lookup
      var pairs = {
        "A": "T",
        "T": "A",
        "C": "G",
        "G": "C"
      }
      let arr = str.split('');

      // the pairs[letter] gives us the value of letter
      
      return arr.map(letter => [letter, pairs[letter]])
    }

    console.log(pairElement("GCG"));
```
[Go up](#goUp)

## <a name="missing"/> Missing letters
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/missing-letters)
>
> Again I did more than it was needed. The solution is more simple.
```
    function fearNotLetter(str) {

      let newStr = '';

      let dif = 0;
      let num = 0;
      let length = str.length;

      // 97 is a in ASCII
      for (var i = 0; i < length; i++) {
        dif = str.charCodeAt(0) - 97
        num = i + 97 + dif;
        if (str.charCodeAt(i) !== num) {
          newStr = String.fromCharCode(num);
          break;
        } else if (length === 26) {
          return undefined;
        }
      }

      return newStr;
    }

    console.log(fearNotLetter("abcdefghijklmnopqrstuvwxyz"));
```
[Go up](#goUp)

## <a name="sunion"/> Sorted Union
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/sorted-union/)
>
> I got the reduce solution from [staovf](https://stackoverflow.com/questions/9229645/remove-duplicate-values-from-js-array)
>
> I just had to figure out how to pass the array so I get the [5] and [4] as they where.
```
  function uniteUnique(arr) {
      let newArr = arr.concat(...arguments)

      let noDub = [];

      noDub = newArr.reduce((acc, num) => {
        if (acc.indexOf(num) < 0) {
          acc.push(num);
        }
        return acc;
      }, []);
      
      return noDub;
    }

    console.log(uniteUnique([1, 3, 2], [1, [5]], [2, [4]]));
```
[Go up](#goUp)

## <a name="convert"/> Convert HTML Entities
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/convert-html-entities/)
>

```
    function convertHTML(str) {
      let newStr = '';
      let regex = /&/g;
      let regex1 = /</g;
      let regex2 = />/g;
      let regex3 = /"/g;
      let regex4 = /'/g;
      let regex5 = /&|<|>|'|"/g;

      // This is strange.
      // It should be if not.
      if (str.search(regex5)) {
        newStr = str;
      }

      let replaceEntities = entitie => {
        if (entitie === '&') {
          newStr = str.replace(regex, '&amp;')
        } else if (entitie === '<') {
          newStr = str.replace(regex1, '&lt;')
        } else if (entitie === '>') {
          newStr = str.replace(regex2, '&gt;')
        } else if (entitie === '"') {
          newStr = str.replace(regex3, '&quot;')
        } else if (entitie === "'") {
          newStr = str.replace(regex4, '&apos;')
        }
      }

      for (var i = 0; i < str.length; i++) {
        replaceEntities(str.charAt(i));
      }
      return newStr;
    }

    console.log(convertHTML('Stuff in "quotation marks"'));
```
[Go up](#goUp)
> Another solution
```
    function convertHTML(str) {
      let arr = str.split('');
      
      for (var i = 0; i < arr.length; i++) {
        switch (arr[i]) {
          case '&':
            arr[i] = '&amp;'; 
            break;
          case '<':
            arr[i] = '&lt;';
            break;
          case '>':
            arr[i] = '&gt;';
            break;
          case '"':
            arr[i] = '&quot;';
            break;
          case "'":
            arr[i] = '&apos;';
            break;
        }
      }
      return arr.join('');
    }

    console.log(convertHTML('Stuff in "quotation marks"'));
```

## <a name="missing"/> Sum All Odd Fibonacci Numbers
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/sum-all-odd-fibonacci-numbers/)
>
> I found the way to get the sequence of fibonachi numbers [here](https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053)
```
function sumFibs(num) {
      let sum = 0;
      let arr = [0, 1];
      let arr1 = []

      // Find the sequence of fibonachi numbers
      for (let i = 2; i < num + 1; i++) {
        arr.push(arr[i - 2] + arr[i - 1])
      }
      // get the odd numbers etc until num
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] % 2 !== 0 && arr[i] <= num) {
          sum += arr[i];
          arr1.push(arr[i])
        }
      }
      console.log(arr1);
      return sum;
    }

    console.log(sumFibs(75025));
```
[Go up](#goUp)

## <a name="sumPrimes"/> Sum All Primes
> [FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/sum-all-primes/)
>
> I found the way to get the primes on [Stackoverflow](https://stackoverflow.com/questions/17389350/prime-numbers-javascript)
```
    function sumPrimes(num) {
    
    function nextPrime(value) {
        if (value > 2) {
          let i, q;
          do {
            i = 3;
            value += 2;
            q = Math.floor(Math.sqrt(value));
            while (i <= q && value % i) {
              i += 2;
            }
          } while (i <= q);
          return value;
        }
        return value === 2 ? 3 : 2;
      }

      let value, result = [];
      for (let i = 0; i < num; i++) {
        value = nextPrime(value);
        result.push(value);
      }

      // I did only this part.

      let sum = 0;
      sum = result.filter(x => x <= num).reduce((acc, value) => acc + value)
      
                              // basic way
                              // let sum = 0;
                              // for (let i = 0; i < result.length; i++) {
                              //   if (result[i] <= num) {
                              //     sum += result[i];
                              //   }
                              // }
      return sum
    }
```
[Go up](#goUp)

## <a name="smallest"/> Smallest Common Multiple

Find the smallest common multiple of the provided parameters that can be evenly divided by both, as well as by all sequential numbers in the range between these parameters.

The range will be an array of two numbers that will not necessarily be in numerical order.

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/smallest-common-multiple/)

It took me 10 hours.
It still doesn't pass the last two tests in FCC, but it works everywhere else.

And it doesn't pass the test because, as I've learned from Niels in the [forum](https://www.freecodecamp.org/forum/t/smallest-common-multiple-call-stack-exceeded/234389/6), FCC has some limits for efficiency. So this code is taking to long...
After some help from Niels the code passed the tests. It follows after this one.

```
    // IT WORKS!
    function smallestCommons(arr) {

      let newArr = arr.sort((a, b) => a - b);

      // get the numbers between the two elements
      let numbers = [];
      let firstElement = newArr[0]
      let secondElement = newArr[1];
      for (let i = 0; i < secondElement; i++) {
        while (firstElement <= secondElement) {
          numbers.push(secondElement--)
        }
      }
      console.log(numbers);


      // find the smallest common perfect divisor
      function findCommon(array) {
    
        let newArray = [...array]
        let multiplier = newArray[0];
        let product = 0;
        let booleans = [];
    
        for (let i = 0; i < newArray.length; i++) {
          booleans.push(false)
        }
    
        // Multiply the first element with multiplier
        // and store the product.
        // Check the product with each value from the
        // inBetweenArray, for a perfect division.
        // Increment the multiplier and check again.
        // In every iteration remover the first value from
        // the inBetweenArray and add the result of the
        // new check at the end (FIFO).
        // If all values are true break the booleans loop
        // If all values are true break the outer loop.
    
        for (;;) {
          product = newArray[0] * multiplier;
          //  console.log('product', product);
          //  console.log('multiplier', multiplier);
          for (let i = 0; i < newArray.length; i++) {
            //  console.log('newArray', newArray[i]);
            //  console.log('1', booleans);
            booleans.shift()
            booleans.push(product % newArray[i] === 0);
            //console.log(booleans);
            let pass = booleans.every(x => x === true)
            //  console.log('pass', pass);
            if (pass) {
              break;
            }
            //    console.log("booleans", booleans);
          }
          let pass2 = booleans.every(x => x === true)
          if (pass2) {
            break;
          }
          //  console.log('2', pass2);
          multiplier++
        }
        return product;
      }
      return findCommon(numbers);;
    }
    
    console.log('result', smallestCommons([23, 18]));
```
[Go up](#goUp)

More efficient code.
```
  
    function smallestCommons(arr) {

      arr.sort((a, b) => b - a);

      // get the numbers between the two elements
      let inBetweenNums = [];
      for (let i = arr[0]; i >= arr[1]; i--) {
        inBetweenNums.push(i)
      }

      // find the smallest common perfect divisor
      let multiplier = 2;
      let product = 0;
      let dividesCleanly = true;

      // Multiply the first two numbers with a multiplier.
      // Check if the product divides perfectly all the numbers
      // If there is a number that doesn't divide perfectly
      // break the loop. So after break, dividesCleanly = true, which
      // is the else, doesn't execute. The dividesCleanly is false
      // so the product does not get returned. So we go to
      // decrement multiplier, and so on.
      // While there is a number that doesn't divide perfectly,
      // the loop will break and the product will never be returned.

      while (true) {
        product = inBetweenNums[0] * inBetweenNums[1] * multiplier;
        //console.log('prod... ', product);
        for (let i = 0; i < inBetweenNums.length; i++) {
         // console.log('inBe...1 ', inBetweenNums[i]);
          if (product % inBetweenNums[i] !== 0) {
           // console.log(inBetweenNums[i]);
            dividesCleanly = false;
            break;
          }
          dividesCleanly = true;
         // console.log(dividesCleanly);
        }
        if (dividesCleanly) {
         // console.log(product);
          return product
        } else {
          multiplier++
        }
      }
    }

   console.log('result', smallestCommons([23, 18]));
```
[Go up](#goUp)

Anyway, because I didn’t try to solve the problem at first place as Niels suggested and I kinda got the solution from a snippet he gave me, I couldn’t leave it like this. I kept thinging that I got lazy and that I just wanted this to finish and go to next challenge. 

But this is not a good habit. I’m here to learn not to pass challenges. So I though I should give it a try to replace the while (true) loop with a do - while loop.

After some time, I got it, and more importantly, I understand how it works.
But to be honest, I took the while (i !== inBetweenNums.length) from the FCC solution. I couldn’t find a way to stop the loop. Even though it’s so obvious. Like, stop the loop when you finally get to iterate through all numbers, which means you didn’t break anywhere, so all are clean.

```
function smallestCommons(arr) {

      arr.sort((a, b) => b - a);

      // get the numbers between the two elements
      let inBetweenNums = [];
      for (let i = arr[0]; i >= arr[1]; i--) {
        inBetweenNums.push(i)
      }

      // find the smallest common perfect divisor
      let multiplier = 2;
      let product = 0;
      let i = 0;

      do {
        product = inBetweenNums[0] * inBetweenNums[1] * multiplier;
        //  console.log('prod... ', product);
        for (i = 0; i < inBetweenNums.length; i++) {
          console.log('1.. ', i);
          if (product % inBetweenNums[i] !== 0) {
            //  console.log(inBetweenNums[i]);
            break;
          }
        }
        multiplier++

        console.log('1.. ', i);
      } while (i !== inBetweenNums.length)
      //  console.log(product);
      return product
    }

    console.log('result', smallestCommons([1, 5]));
```

[Go up](#goUp)

## <a name="niels"/>  Smallest Common Multiple code from Niels

[original code](https://codepen.io/niels_bom/pen/pxLKYX)
```
    // code from Niels Bom
    // a guy from FCC Forum

    // Here I changed a bit the order of the functions
    // to make it more understandable.

    // // https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/smallest-common-multiple/
    // // See https://en.wikipedia.org/wiki/Divisor for naming
    //
    //
    // // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Sequence_generator_(range)

  // Generate the numbers
    const range = (start, stop, step) => {
      return Array.from({
          length: (stop - start) / step
        },
        (_, i) => start + (i * step)
      );
    }

    const generateDivisors = arr => {
      // No input checking: we assume two positive integers in an array
      arr.sort((a, b) => a > b); // Low to high
      //console.log(arr);
      // Generate the numbers between the two first elements.
      return range(arr[0], arr[1] + 1, 1);
    };

    const smallestCommons = arr => {
      // Checking higher divisors first is more efficient
      let divisors = generateDivisors(arr); //.reverse();
      if (divisors[0] === 1) {
        divisors.shift(); // all integers are cleanly divisible by 1
      }
      return getSmallestCommonMultiple(divisors);
    };



    var numChecks = 0;
    const getSmallestCommonMultiple = (divisors) => {
      // For efficiency we make use of the following fact:
      //   scm
      // for [1, 2, 3, 4, 5, 6, 7] is a product
      //   of scm
      // for [1, 2, 3, 4, 5, 6] and X
      // 420 == > 60 * X
      // This means we only have to check 60, 120, 180 .... 420.

      // Question:
      // I don't see how you make use of the above fact.
      // It seems that you check all numbers,
      // from 24 untill 10160677800
      let step = 1;
      if (divisors.length > 2) {
        console.log('div', divisors);
        console.log('div.len', divisors.length);
        let divisorsSmaller = divisors.slice();
        divisorsSmaller.pop();
        console.log('divisorsSmaller', divisorsSmaller);
        // Here we get the first two divisors, which are the smallest
        // So instead of running the function with all divisors,
        // we call it with only two, the smallest ones.
        // Question: In FCC Solutions, says that is more efficient
        // to multiply with the highest ones.
        step = getSmallestCommonMultiple(divisorsSmaller); // Recursion
      }
      console.log('step = ' + step);

      // First iteration of the loop sets it to step * 1;
      let scmCandidate = 0;
      let candidateFound = false;
      // from the two we take the last one, which is higher
      let highestDivisor = divisors[divisors.length - 1];
      console.log('highestDivisor', highestDivisor);
      // While candidateFound is true, Increment step
      // if the getSmallestCommonMultiple is smaller than
      // the highestDivisor, continue...
      while (!candidateFound) {
        scmCandidate += step;
        if (scmCandidate < highestDivisor) {
          continue;
        }
        // if (scmCandidate > 500) {console.log("INFINITE");
        // throw new Error("Something went badly wrong!");}
        // We reverse here because the higher divisors
        // have the highest chance of not cleanly dividing
        // the candidate

        // Question: why if I take out slice(), it doesn't
        // log out always the reversed array,
        // and it gives sometimes the normal divisors array
        for (let divisor of divisors.slice().reverse()) {
          numChecks++;
          console.log('divisors.slice().reverse()', divisors.slice().reverse());
          console.log('numChecks', numChecks);
          console.log(scmCandidate + " % " + divisor);

          // How nice! You don't even do the division,
          // you just check for it.
          if (scmCandidate % divisor !== 0) {
            // The first non-clean division we find
            // is enough to disregard this candidate.
            candidateFound = false;
            break;
          }
          // Because this scm was cleanly divided by all divisors we now know:
          candidateFound = true;
        }
      }
      return scmCandidate;
    }



    console.log("*******");
    console.log(smallestCommons([23, 31]));
    console.log("We checked divisors " + numChecks + " times.");
```
[Go up](#goUp)

Checking the difference between starting from the largest or lowest array numbers
```

    // code from Niels Bom
    // a guy from FCC Forum
    
    // Here I changed a bit the order of the functions
    // to make it more understandable.
    
    // The funny thing is that in freecodecamp they say
    // that the a perfect divisor of largest numbers is morelikely to be the
    // smallest common multiple, for the rest.
    // But here it is proven that we do less checks if we start with
    // the smallest ones.
    // Checks with smallest = 702
    // Checks with largest = 1455
    
    // https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/smallest-common-multiple/
    // See https://en.wikipedia.org/wiki/Divisor for naming
    
    
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Sequence_generator_(range)
    // Generate the numbers
    const range = (start, stop, step) => {
      return Array.from({
          length: (stop - start) / step
        },
        (_, i) => start + (i * step)
      );
    }
    
    const generateDivisors = arr => {
      // No input checking: we assume two positive integers in an array
      arr.sort((a, b) => a > b); // Low to high
      //console.log(arr);
      // Generate the numbers between the two first elements.
      return range(arr[0], arr[1] + 1, 1);
    };
    
    const smallestCommons = arr => {
      // Checking higher divisors first is more efficient
      let divisors = generateDivisors(arr).reverse();
      if (divisors[0] === 1) {
        divisors.shift(); // all integers are cleanly divisible by 1
      }
      return getSmallestCommonMultiple(divisors);
    };
    
    
    
    var numChecks = 0;
    const getSmallestCommonMultiple = (divisors) => {
      // For efficiency we make use of the following fact:
      // scm for [1,2,3,4,5,6,7] is a product
      // of scm for [1,2,3,4,5,6] and X
      // 420 ==> 60 * X
      // This means we only have to check 60, 120, 180 .... 420.
      let step = 1;
      if (divisors.length > 2) {
        console.log('div', divisors);
        console.log('div.len', divisors.length);
        let divisorsSmaller = divisors.slice();
        divisorsSmaller.pop();
        console.log('divisorsSmaller', divisorsSmaller);
        // Here we get the first two divisors, which are the smallest
        // So instead of running the function with all divisors,
        // we call it with only two, the smallest ones.
        // Question: In FCC Solutions, says that is more efficient
        // to multiply with the highest ones.
        step = getSmallestCommonMultiple(divisorsSmaller); // Recursion
      }
      console.log('step = ' + step);
    
      // First iteration of the loop sets it to step * 1;
      let scmCandidate = 0;
      let candidateFound = false;
      // from the two we take the last one, which is higher
      let highestDivisor = divisors[divisors.length - 1];
      console.log('highestDivisor', highestDivisor);
      // While candidateFound is true, Increment step
      // if the getSmallestCommonMultiple is smaller than
      // the highestDivisor, continue...
      while (!candidateFound) {
        scmCandidate += step;
        if (scmCandidate < highestDivisor) {
          continue;
        }
        // if (scmCandidate > 500) {console.log("INFINITE");
        // throw new Error("Something went badly wrong!");}
        // We reverse here because the higher divisors
        // have the highest chance of not cleanly dividing
        // the candidate
    
        // Question: why if I take out slice(), it doesn't
        // log out always the reversed array,
        // and it gives sometimes the normal divisors array
        for (let divisor of divisors.slice()) //.reverse())
        {
          numChecks++;
          console.log('divisors.slice().reverse()', divisors.slice());
          console.log('numChecks', numChecks);
          console.log(scmCandidate + " % " + divisor);
    
          // How nice! You don't even do the division,
          // you just check for it.
          if (scmCandidate % divisor !== 0) {
            // The first non-clean division we find
            // is enough to disregard this candidate.
            candidateFound = false;
            break;
          }
          // Because this scm was cleanly divided by all divisors we now know:
          candidateFound = true;
        }
      }
      return scmCandidate;
    }
    
    
    
    console.log("*******");
    console.log(smallestCommons([23, 31]));
    console.log("We checked divisors " + numChecks + " times.");

```

## <a name="drop"/> Drop it

Given the array arr, iterate through and remove each element starting from the first element (the 0 index) until the function func returns true when the iterated element is passed through it.

Then return the rest of the array once the condition is satisfied, otherwise, arr should be returned as an empty array.

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/drop-it/)

Must check also the ultra concise code of [FCC solutions](https://guide.freecodecamp.org/certifications/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/drop-it/)

I'm again doing too much. But it works. ;)
```
  function dropElements(arr, func) {
      // Drop them elements.
      
      let savedNumbers = []
      let allTrue = arr.every(x => func(x));
     
      for (var i = 0; i < arr.length; i++) {
        if (func(arr[i])) {       
          savedNumbers = arr.slice(i);       
          break;
        } else if (allTrue) {
          savedNumbers = [...arr]
        } else if (!allTrue) {
          savedNumbers.length = 0;
        }
      }
      return savedNumbers;
    }

    console.log('1 = ', dropElements([1, 2, 3, 4], function(n) {
      return n >= 3;
    }));

    
```
[Go up](#goUp)

This one is the FCC solution but with if's instead of turnary operator.
```
  function dropElements(arr, func) {
      // Drop them elements.
      let savedNumbers = [];

      if (arr.findIndex(func) >= 0) {
        savedNumbers = arr.slice(arr.findIndex(func), arr.length)
      } else if (savedNumbers.findIndex(func) <= 0) {
        savedNumbers = arr.slice(arr.length, arr.length)
      }
      return savedNumbers;
    }

    console.log('1 = ', dropElements([1, 2, 3, 4], function(n) {
      return n >= 3;
    }));
```
And again but with splice instead of slice.
```
  function dropElements(arr, func) {
      // Drop them elements.
      let savedNumbers = [...arr];
      return savedNumbers.splice(savedNumbers.findIndex(func) >= 0 ? savedNumbers.findIndex(func) : savedNumbers.length, savedNumbers.length)
    }
```

## <a name="stream"/> Steamroller
[FCC Challenge](https://guide.freecodecamp.org/certifications/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/steamroller/)

Flatten a nested array.
You must account for varying levels of nesting.

This one passes the tests but it's hardcoded
```
  function steamrollArray(arr) {
    // I'm a steamroller, baby
  
    let flatArray = [...arr]
  
    return flatArray.flat(4);;
  }
  
  console.log(steamrollArray([1, [2],
    [3, [
      [4]
    ]]
  ]));
```
[Go up](#goUp)

But this one is not hardcoded! :)
```

  function steamrollArray(arr) {
    // I'm a steamroller, baby

    let flatArray = [...arr]
    let counter = 1;
    for (var i = 0; i < flatArray.length; i++) {
      if (Array.isArray(flatArray[i]) || typeof flatArray[i] === 'object') {
        counter++
      }
    }
    console.log(counter);
    return flatArray.flat(counter);;
  }

  console.log(steamrollArray([1, [2],
    [3, [
      [4]
    ]]
  ]));

```
[Go up](#goUp)

Now this one is really not hard coded. ;)
```
  function steamrollArray(arr) {
      // I'm a steamroller, baby

      let flatArray = [...arr]
      let counter = 0;
      
      // Just increment the counter for every element.
      for (var i = 0; i < flatArray.length; i++) {
        counter++
      }
      console.log(counter);
      return flatArray.flat(counter);;
    }

    console.log(steamrollArray([1, [2],
      [3, [
        [4]
      ]]
    ]));
```

Found it in stackOverflow. It looks like an FCC solution.
```
  function steamrollArray(arr) {

     
      // The starting point is  an empty array
      // then as it iterates over the array,
      // it first checks if the next element
      // 'toFlatten' is an array,
      // if it is it calls recursively the flatten
      // function and it concats it with an empty array.
      // It uses recursively this: `[].concat(arr)`
      // which flattens an array.
      // Otherwise, it lets it be.
      
      function flatten(arr) {
        return arr.reduce(function(flat, toFlatten) {
          return flat.concat(
            Array.isArray(toFlatten) ?
            flatten(toFlatten) : toFlatten);
        }, []);
      }

      // same as above but with arrows
    //   const flatten = (arr) =>
    //     arr.reduce((flat, next) =>
    //       flat.concat(Array.isArray(next) ?
    //         flatten(next) : next), []);
   
     return flatten(arr);
   }

    console.log(steamrollArray([1, [2],
      [3, [
        [4]
      ]]
    ]));
```
[Go up](#goUp)

FCC Basic solution, with arrow function
```
function steamrollArray(arr) {
      // I'm a steamroller, baby
      let flatArray = [];

      // check each element of the array, 
      // if it's not an array, push it to 
      // the flatArray, if it is, 
      // run the flatten array again,
      // with the value of the next element.
      // In this way we go dipper and dipper
      // into the array, until every single 
      // element is not an array.
      
      var flatten = (arg) => {
        if (!Array.isArray(arg)) {
          flatArray.push(arg)
        } else {
          for (let arr in arg) {
            flatten(arg[arr])
          }
        }
      }

      arr.forEach(flatten);

      return flatArray;
    }
    console.log(steamrollArray([1, [2],
      [3, [
        [4]
      ]]
    ]));
```
[Go up](#goUp)

FCC intermediate solution
```
function steamrollArray(arr) {
      // I'm a steamroller, baby

      console.log(arr);
      
      // concat each element of the array with an empty array.
      // By this we get one level flat.
      
      let flatArray = [].concat(...arr);

      console.log(flatArray);
      
      // Here we use recursion in a ternary operator.
      // If an element is an array, call again the 
      // steamrollArray function on flatArray. 
      // If it's not return the flatArray.
      // So again we get one level flaten 
      // by this [].concat(...arr).
      // Eventually all elements will be concateneted 
      // to an empty array by the flatArray.
      
      return flatArray.some(Array.isArray) ?
        steamrollArray(flatArray) : flatArray;
    }
    console.log('result', steamrollArray([1, [2],
      [3, [
        [4]
      ]]
    ]));
```
[Go up](#goUp)

## <a name="binary"/> Binary Agents

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/binary-agents/)

Return an English translated sentence of the passed binary string.
The binary string will be space separated.

Nice and clean.;)
```
    function binaryAgent(str) {

      let arr = str.split(' ');

      // turn binary to decimals
      // turn decimals/ascii values, to letters
      let newArr = arr.map(x => parseInt(x, 2)).map(x => String.fromCharCode(x));
      
       // Actually after checking the advanced FCC solution I came up with this:
       // return str.split(' ').map(x => parseInt(x, 2)).map(x => String.fromCharCode(x)).join('');
       // The funny thing though is that they have the fromCharCode before the parseInt.

      return newArr.join('');
    }

    console.log(binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"));
```
[Go up](#goUp)

FCC Intermediate  Solutioin. 

I found it interestring because at the beginning I was trying to iterate the same way, but I couldn't figure out this code: 
`power = Math.pow(2, +str[s].length - t - 1);`. And of course I'm still not able to see where to get the deciaml number, where to get the letter from it, or where to reset it.

```
  function binaryAgent(str) {
      // Separate the binary code by space.
      str = str.split(' ');
      var power;
      var decValue = 0;
      var sentence = '';

      // Check each binary number from the array.
      for (var s = 0; s < str.length; s++) {
        // Check each bit from binary number
        for (var t = 0; t < str[s].length; t++) {
          // This only takes into consideration the active ones.
          if (str[s][t] == 1) {
          
            // Here we get the position of '1' in the
            // binary element, by getting the binary's length,
            // which is always 8, and subtracking from it
            // the index of '1'. Then we subtrack again 1,
            // in order to cover the 0 index. So for example,
            // for `00000001` we get `8 - 7 - 1` and that is 
            // 2 in the power of 1 = 1 which is the value
            // of the first number of the binary set. 
            // So by raising the number of the index of the 
            // binary set to the power of two. We get the 
            // decimal number.
            // The values of the binary set are:
            // 1, 2, 4, 8, 16, 32, 64, 128.
            
            console.log(str[s]);
            console.log('str[s] ', str[s].length, '-', t, '-', 1);
            
            // This is quivalent to 2 ** position
            power = Math.pow(2, +str[s].length - t - 1);
            
            console.log('power', power);
            console.log('decValue', decValue);
            
            decValue += power;

            // Record the decimal value by adding the number to the previous one.
          }
        }

        // After the binary number is converted to decimal, convert it to string and store
        sentence += (String.fromCharCode(decValue));

        // Reset decimal value for next binary number.
        decValue = 0;
      }

      return sentence;
    }
    console.log(binaryAgent("00000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111"));
  
```
[Go up](#goUp)

## <a name="everything"/> Everything Be True

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/everything-be-true/)

Check if the predicate (second argument) is truthy on all elements of a collection (first argument).
```
  function truthCheck(collection, pre) {
      // Is everyone being true?

      for (let prop in collection) {
        if (!collection[prop][pre]) {
          return false
        }
      }
      return true;
    }
    console.log(truthCheck([{
      "user": "Tinky-Winky"

    }, {
      "user": "Dipsy",
      "sex": "male"
    }, {
      "user": "Laa-Laa",
      "sex": "female"
    }, {
      "user": "Po",
      "sex": "female"
    }], "sex"));
```
[Go up](#goUp)


## <a name="everything"/> Arguments Optional

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/arguments-optional)

Create a function that sums two arguments together. If only one argument is provided, then return a function that expects one argument and returns the sum.

For example, addTogether(2, 3) should return 5, and addTogether(2) should return a function.

Calling this returned function with a single argument will then return the sum:

var sumTwoAnd = addTogether(2);

sumTwoAnd(3) returns 5.

If either argument isn't a valid number, return undefined.

```
  function addTogether() {
      let x = arguments[0];
      let arr = [...arguments]

      if (typeof x === 'number') {
        for (var i = 0; i < arr.length; i++) {
          if (arr.length != 1 && typeof arr[1] == 'number') {
            return arr.reduce((x, y) => x + y)
          } else if (arr.length === 1) {
            return (y) => {
              if (typeof y !== 'number') {
                return;
              } else {
                return x + y;
              }
            }
          }
        }
      }
    }
```
[Go up](#goUp)

The FCC advanced solution is awesome!
```
   //jshint esversion: 6
    function addTogether() {
    
      var args = Array.from(arguments);
      
      // if some of the arguments are not a number
      // return undefined
      return args.some(n => typeof n !== 'number') ? 
        undefined: 
        
        // if we got more than one argument
        // when calling the function at first place
        // do the addition.
        args.length > 1 ?
          args.reduce((acc, n) => acc += n, 0):
          
          // if not, return a function that takes 
          // one more argument, but 
          // check first if it's a number...
          (n) => typeof n === "number" ? 
            n + args[0]:
            undefined;
    }

    // test here
    addTogether(2,3);
```
[Go up](#goUp)

## <a name="person"/> Make a Person

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/make-a-person/)

Fill in the object constructor with the following methods below:

getFirstName() getLastName() getFullName() setFirstName(first) setLastName(last) setFullName(firstAndLast)
Run the tests to see the expected output for each method.

The methods that take an argument must accept only one argument and it has to be a string.

These methods must be the only available means of interacting with the object.
```
function Person(firstAndLast) {
      let name = firstAndLast.split(" ")[0];
      let lastname = firstAndLast.split(" ")[1];
      // Complete the method below and implement the others similarly
      this.setFirstName = (first) => {
        name = first;
        return name;
      }
      this.setLastName = (last) => {
        lastname = last;
        return lastname;
      }
      this.setFullName = (firstAndLast) => {
        let arr = firstAndLast.split(' ');
        for (var i = 0; i < arr.length; i++) {
          name = arr[0];
          lastname = arr[1];
        }
      }

      this.getFirstName = () => name;
      this.getLastName = () => lastname;
      this.getFullName = () => name + " " + lastname;

      return firstAndLast;
    };

    var bob = new Person('Bob Ross');
    console.log(bob.setLastName('Big'));
    console.log(bob.getFirstName());
    console.log(bob.getLastName());
    console.log(Object.keys(bob));
    
```
[Go up](#goUp)

## <a name="everything"/> Map the Debris

Return a new array that transforms the elements' average altitude into their orbital periods (in seconds).

The array will contain objects in the format {name: 'name', avgAlt: avgAlt}.

You can read about orbital periods on Wikipedia.

The values should be rounded to the nearest whole number. The body being orbited is Earth.

[FCC Challenge](https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/intermediate-algorithm-scripting/map-the-debris)

I had a dificulty finding the right formula, so I looked at the the hinds.
```
function orbitalPeriod(arr) {
      var GM = 398600.4418;
      var earthRadius = 6367.4447;

      let newArr = Array.from(arr);

      for (var i = 0; i < newArr.length; i++) {

        let avgAlt = newArr[i].avgAlt;

        let numerator = Math.pow((earthRadius + avgAlt), 3);
        let sqrtFraction = numerator / GM;
        let sqrt = Math.sqrt(sqrtFraction);
        let _2pi = 2 * Math.PI;
        let result = Math.round(_2pi * sqrt);

        for (let prop in newArr[i]) {
          //  console.log(newArr[i][prop]);
          delete newArr[i].avgAlt;
          newArr[i].orbitalPeriod = result;
        }
      }

      return newArr;
    }

    console.log(orbitalPeriod([{
      name: "sputnik",
      avgAlt: 35873.5553
    }]));

    console.log('2', orbitalPeriod([{
      name: "iss",
      avgAlt: 413.6
    }, {
      name: "hubble",
      avgAlt: 556.7
    }, {
      name: "moon",
      avgAlt: 378632.553
    }]));

```
[Go up](#goUp)

